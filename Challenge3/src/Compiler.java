import java.util.Map;
import java.util.List;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.AbstractMap;
import java.util.Stack;

/** This class compiles the code parsed by the lexer. */
public class Compiler {

  LexerGenerator lexer;
  List<Map.Entry<String, String>> lexerList;
  List<Map.Entry<String, Integer>> varList = new ArrayList<>();

  // Variable for keeping track of the hierarcy of while loops.
  Stack<Integer> controlStack = new Stack<Integer>();

  // Constants for the symbols.
  String CLEAR = "CLEAR";
  String INCR = "INCR";
  String DECR = "DECR";
  String WHILE = "WHILE";
  String IF = "IF";
  String ELSE = "ELSE";
  String NOT = "NOT";
  String DO = "DO";
  String SEMICOLON = "SEMICOLON";
  String NAME = "NAME";
  String END = "END";

  // Get the array generated by the lexer at initialization.
  public Compiler(LexerGenerator lexer) {
    this.lexer = lexer;
    lexerList = lexer.lexerArray;
  }

  /**
   * Processor method that does the final procesing of the code and returns the values of the
   * variables.
   */
  public void compileCode() {
    for (int i = 0; i < lexerList.size(); i++) {
      if (lexerList.get(i).getKey() == CLEAR) {
        processClear(i);
      }

      if (lexerList.get(i).getKey() == INCR) {
        processIncr(i);
      }

      if (lexerList.get(i).getKey() == DECR) {
        processDecr(i);
      }

      if (lexerList.get(i).getKey() == WHILE) {
        // Go through all the conditions.
        for (Map.Entry<String, Integer> entry : varList) {
          i = processWhile(i, entry);
        }
      }

      if (lexerList.get(i).getKey() == IF) {
        // Go through all the conditions.
        for (Map.Entry<String, Integer> entry : varList) {
          i = processIf(i, entry);
        }
      }

      if (lexerList.get(i).getKey() == ELSE) {
        i = processElse(i);
      }

      if (lexerList.get(i).getKey() == END) {
        i = processEnd(i);
      }
    }
  }

  /**
   * Helper method that applies the clear operation.
   *
   * @param i the position in the lexer array.
   */
  private void processClear(int i) {
    Boolean varExists = false;

    for (Map.Entry<String, Integer> entry : varList) {
      if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
        varExists = true;
        entry.setValue(0);
      }
    }

    if (varExists == false) {
      Map.Entry<String, Integer> entry =
          new AbstractMap.SimpleEntry<String, Integer>(lexerList.get(i + 1).getValue(), 0);
      varList.add(entry);
    }
  }

  /**
   * Helper method that applies the increase operation.
   *
   * @param i the position in the lexer array.
   */
  private void processIncr(int i) {
    for (Map.Entry<String, Integer> entry : varList) {
      if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
        entry.setValue(entry.getValue() + 1);
      }
    }
  }

  /**
   * Helper method that applies the decrease operation.
   *
   * @param i the position in the lexer array.
   */
  private void processDecr(int i) {
    for (Map.Entry<String, Integer> entry : varList) {
      if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
        entry.setValue(entry.getValue() - 1);
      }
    }
  }

  /**
   * Helper method that process a while operation when encountered.
   *
   * @param i the position in the lexer array.
   * @param entry the entry to compare the values to.
   * @return return the position in the code after the processing.
   */
  private int processWhile(int i, Map.Entry<String, Integer> entry) {
    // Check that the condition of the while loop is satisfied.
    if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
      if (entry.getValue().toString().equals(lexerList.get(i + 3).getValue())) {
        for (int j = i; j >= i; j++) {
          if (lexerList.get(j).getKey() == END) {
            i = j;
            break;
          }
        }
      } else {
        controlStack.push(i);
      }
    }
    return i;
  }

  /**
   * Helper method that process a while operation when encountered.
   *
   * @param i the position in the lexer array.
   * @param entry the entry to compare the values to.
   * @return the position in the code after the processing.
   */
  private int processIf(int i, Map.Entry<String, Integer> entry) {
    // Check if the if's condition is satisfied
    if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
      if (entry.getValue().toString().equals(lexerList.get(i + 3).getValue())) {
        i = processCodeBlock(i);
      } else {
        controlStack.push(-1); // -1 pushed for unsatisfied condition.
      }
    }
    return i;
  }

  /**
   * Helper method that processes the else operation.
   *
   * @param i the position in the lexer array.
   * @return the position in the code after the processing.
   */
  private int processElse(int i) {
    if (controlStack.peek() == -1) {
      // Keep track of how many subsequent blocks to skip
      int skip = 0;

      // Go through the code block
      for (int j = i; j >= i; j++) {
        // If a while, another if or else is encountered increment the skip variable.
        if (lexerList.get(j).getKey() == WHILE
            || lexerList.get(j).getKey() == IF
            || lexerList.get(j).getKey() == ELSE) {
          skip += 1;
        }

        // If and end is encountered and there are blocks to skip (tracked by skip variable),
        // decrese
        // the skip variable.
        if (lexerList.get(j).getKey() == END && skip > 0) {
          skip -= 1;
        }

        // If there are no more skips execute the code from that point on.
        if (lexerList.get(j).getKey() == END && skip == 0) {
          i = j + 1;
          controlStack.pop(); // Pop, there is nothing else after an else.
          break;
        }
      }
    }
    return i;
  }

  /**
   * Helper method that processes the end operation.
   *
   * @param i the position in the lexer array.
   * @return return the position in the code after the processing.
   */
  private int processEnd(int i) {
    Integer blockIndex = controlStack.peek();

    // Check if we are inside a block that was executed.
    if (blockIndex >= 0) {
      for (Map.Entry<String, Integer> entry : varList) {
        // Check that the condition is satisfied.
        if (entry.getKey().equals(lexerList.get(blockIndex + 1).getValue())) {
          if (entry.getValue().toString().equals(lexerList.get(blockIndex + 3).getValue())) {
            controlStack.pop();
            continue;
          } else {
            i = blockIndex;
          }
        }
      }
    } else {
      // If we skipped an if and there is no else pop it from the stack. Otherwise continue.
      if (lexerList.get(i + 2).getKey() != ELSE) {
        controlStack.pop();
      }
    }
    return i;
  }

  /**
   * Helper method that skips the code block after an if is encountered.
   *
   * @param i the position in the lexer array.
   * @return the position in the code after the processing.
   */
  private int processCodeBlock(int i) {
    // Keep track of how many subsequent blocks to skip
    int skip = 0;

    // Go through the code block
    for (int j = i; j >= i; j++) {
      // If a while, another if or else is encountered increment the skip variable.
      if (lexerList.get(j).getKey() == WHILE
          || lexerList.get(j).getKey() == IF
          || lexerList.get(j).getKey() == ELSE) {
        skip += 1;
      }

      // If and end is encountered and there are blocks to skip (tracked by skip variable), decrese
      // the skip variable.
      if (lexerList.get(j).getKey() == END && skip > 0) {
        skip -= 1;
      }

      // If there are no more skips execute the code from that point on.
      if (lexerList.get(j).getKey() == END && skip == 0) {
        i = j + 1;
        controlStack.push(-2); // -2 for satisfied condition and move on through the code.
        break;
      }
    }
    return i;
  }

  /** Debug method that prints the variables and their values. */
  public void printState() {
    for (Map.Entry<String, Integer> entry : varList) {
      System.out.println(entry.getKey() + " : " + entry.getValue());
    }
  }
}
