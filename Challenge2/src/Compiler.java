import java.util.Map;
import java.util.List;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.AbstractMap;
import java.util.Stack;

/** This class compiles the code parsed by the lexer. */
public class Compiler {

  LexerGenerator lexer;
  List<Map.Entry<String, String>> lexerList;
  List<Map.Entry<String, Integer>> varList = new ArrayList<>();

  // Variable for keeping track of the hierarcy of while loops.
  Stack<Integer> whileStack = new Stack<Integer>();

  // Constants for the symbols.
  String CLEAR = "CLEAR";
  String INCR = "INCR";
  String DECR = "DECR";
  String WHILE = "WHILE";
  String NOT = "NOT";
  String DO = "DO";
  String SEMICOLON = "SEMICOLON";
  String NAME = "NAME";
  String END = "END";

  // Get the array generated by the lexer at initialization.
  public Compiler(LexerGenerator lexer) {
    this.lexer = lexer;
    lexerList = lexer.lexerArray;
  }

  /**
   * Processor method that does the final procesing of the code and returns the values of the
   * variables.
   */
  public void compileCode() {
    for (int i = 0; i < lexerList.size(); i++) {
      if (lexerList.get(i).getKey() == CLEAR) {
        processClear(i);
      }

      if (lexerList.get(i).getKey() == INCR) {
        processIncr(i);
      }

      if (lexerList.get(i).getKey() == DECR) {
        processDecr(i);
      }

      if (lexerList.get(i).getKey() == WHILE) {
        // Go through all the conditions.
        for (Map.Entry<String, Integer> entry : varList) {
          i = processWhile(i, entry);
        }
      }

      if (lexerList.get(i).getKey() == END) {
        i = processEnd(i);
      }
    }
  }

  /** Debug method that prints the variables and their values. */
  public void printState() {
    for (Map.Entry<String, Integer> entry : varList) {
      System.out.println(entry.getKey() + " : " + entry.getValue());
    }
  }

  /**
   * Helper method that applies the clear operation.
   *
   * @param i the position in the lexer array.
   */
  private void processClear(int i) {
    Boolean varExists = false;

    for (Map.Entry<String, Integer> entry : varList) {
      // Go through all the variables provided and set their value to 0.
      if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
        varExists = true;
        entry.setValue(0);
      }
    }

    // If no variable to set to 0 was found then instatiate a new variable in the list with the
    // value 0.
    if (varExists == false) {
      Map.Entry<String, Integer> entry =
          new AbstractMap.SimpleEntry<String, Integer>(lexerList.get(i + 1).getValue(), 0);
      varList.add(entry);
    }
  }

  /**
   * Helper method that applies the increase operation.
   *
   * @param i the position in the lexer array.
   */
  private void processIncr(int i) {
    for (Map.Entry<String, Integer> entry : varList) {
      if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
        entry.setValue(entry.getValue() + 1);
      }
    }
  }

  /**
   * Helper method that applies the decrease operation.
   *
   * @param i the position in the lexer array.
   */
  private void processDecr(int i) {
    for (Map.Entry<String, Integer> entry : varList) {
      if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
        entry.setValue(entry.getValue() - 1);
      }
    }
  }

  /**
   * Helper method that process a while operation when encountered.
   *
   * @param i the position in the lexer array.
   * @param entry the entry to compare the values to.
   * @return return the position in the code after the processing.
   */
  private int processWhile(int i, Map.Entry<String, Integer> entry) {
    // This ifs checks that the condition of the while loop is satisfied.
    if (entry.getKey().equals(lexerList.get(i + 1).getValue())) {
      if (entry.getValue().toString().equals(lexerList.get(i + 3).getValue())) {
        // If satisfied move to the closest end entry and move the lexer array pointer to that
        // point.
        for (int j = i; j >= i; j++) {
          if (lexerList.get(j).getKey() == END) {
            i = j;
            break;
          }
        }
      } else {
        whileStack.push(i); // Move on in the code and remember the position of the while block
      }
    }
    return i;
  }

  /**
   * Helper method that processes the end operation.
   *
   * @param i the position in the lexer array.
   * @return return the position in the code after the processing.
   */
  private int processEnd(int i) {
    // Get the position of the most recent while operation saved in the stack.
    Integer blockIndex = whileStack.peek();

    for (Map.Entry<String, Integer> entry : varList) {
      // Check if the condition is satisfied.
      if (entry.getKey().equals(lexerList.get(blockIndex + 1).getValue())) {
        if (entry.getValue().toString().equals(lexerList.get(blockIndex + 3).getValue())) {
          whileStack.pop(); // if condition is satisfied pop the while and move out the loop
          continue; // exit the loop and move to the next entry.
        } else {
          i = blockIndex; // Go to the beginning of the while block if condition not satisfied.
        }
      }
    }
    return i;
  }
}
